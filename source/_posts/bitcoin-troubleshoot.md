---
title: 比特币-自问自答（一）
date: 2018-02-25 22:41:36
categories: blockchain
tags: [bitcoin]
description: 发给一个不合法的地址会发生什么？关键词：地址，私钥，公钥，椭圆曲线，签名，交易，UTXO

---

## 发给一个不合法的地址会怎么样？

我第一反应想到的是能发出去吗？之所以想到这个问题是，因为我们现实生活中转账的时候，如果对方账号不存在是转不过去的。而且在比特币系统中没有存在银行这么一个中心机构给我们干这个事情，在《精通比特币2》第四章中的Introduction部分说到
> “The digital keys in a user’s wallet are completely independent of the bitcoin protocol and can be generated and managed by the user’s wallet software without reference to the blockchain or access to the internet. 

存储在用户钱包中的数字密钥是完全独立余比特币协议，可由用户钱包软件生成并管理，无需参照区块链或访问网络，**这其实就说明一件事，我转账的时候，并不需要对方账户存在，因为本身地址生成的时候，网络事先也是不知道的。** 那如果可以发送的话，是给了谁？
为了搞懂这个问题，必须要先知道地址到底是什么和整个交易是怎么样的这两个关键的问题。

我很久之前看过有关比特币的资料，印象中是把公钥当作地址

---
_展开 -- 公钥私钥_

公钥是密码学里面非对称加密里面的概念，一个密钥对包含一个私钥和一个公钥。有非对称就有对称，这个就有点类似门锁，有些门锁是不会自动上锁，撞上门还可以开进去，锁门是需要钥匙锁的。然后像球性锁，或者酒店里面的锁，一旦撞上门，那就只能通过钥匙打开，没有钥匙是打不开的。在《趣味数学》这本书里面举了一个例子，你想一个3位数，比如123，然后乘以91，告诉我结果（11193）末尾三位，193在我只知道193的情况下，我能知道你原来想的是什么，只要193*11=2123，取末三位，123。原理是91*11=1001，任何一个三位数乘以1001末尾三位不变。这里91就是公钥，11就是私钥。我把公钥告诉大伙，但私钥保密，这样在被人传送消息给我的时候就能保证只有我能够阅读到原来的信息。当然真实加密中不会用这么简单的算法。但原理类似。那同样，我怎么知道发送给我的信息的就来自与那个人，而没有被调包。比如A->B,A可以先用B的公钥加密，在用自己的私钥加密。那么B就收到的就是SKA(PKB(msg)),然后用A的公钥解密，就可以确定是A发过来的，然后在用自己的私钥解密就得到了信息。

_关闭 -- 公钥私钥_

---

但比特币系统中不能完全把公钥和地址对等起来。当产生了一个钥匙对之后，公钥经过两次哈希运算,分别是`SHA256`和`RIPEMD160`,得到公钥哈希，pubKeyHash,然后再用`base58`格式编码得到了我们常见的比特币地址。这里`base58`只是编码而已，不是加密，更不是非对称加密。所以是可以还原到公钥哈希的。

来自《精通比特币2》上的图

![address](http://onexs3cnv.bkt.clouddn.com/1785959-6fc43eee55666ff2.png)

为什么还要经过两次哈希运算呢？我的理解是进一步的保证了不可逆计算。那为什么要用`base58`编码呢，其实是为了简便的表示和压缩字节数据。

搞懂了地址是什么，再来看交易，一笔交易的本质是什么，`**我的理解是交易就是自己拿一把钥匙打开一把对应的门，拿出里面的钱从另一个有上述酒店锁的门缝里塞进去，然后只有这个拥有这个门的钥匙的人才能进去打开。**`这里暂时不考虑coinbase交易，也就是挖矿奖励。当然会涉及到找零机制，酒店工作人员会把多余的钱塞到另一间房，而转账者有这间房的钥匙。那么这个酒店的房间总共有(那其实

> “The size of bitcoin’s private key space, (2^256) is an unfathomably large number. It is approximately 10^77 in decimal. For comparison, the visible universe is estimated to contain 10^80 atoms.”

可以当作无限个了，也就是你随便想一个地址字符串，转钱到这里，相当于你随便塞了一笔钱到一个陌生的房间，那么如果这个世界上恰好有人拥有这个房间的钥匙，那么就相当于送了他一笔钱，或者等以后有人恰好钱包给他生成了这个地址（地址冲突的概率是存在的），那么他会发现，他刚买了一个新钱包，而这个钱包里面有一笔钱。如果是不合法的地址呢，因为现在很多钱包软件出来，所以我是钱包软件制作者的话，我会在前段检查地址的合法性，不然这笔钱就永远遗失了，因为谁也没有钥匙，相当于就被放进了一个黑洞。

来自《精通比特币2》上的图

![address type](http://onexs3cnv.bkt.clouddn.com/Screen%20Shot%202018-03-02%20at%208.59.44%20AM.png)

常见的比特币地址是由1开头的。


---

_展开 -- 交易解锁脚本_

转账，无非就是从一个地址到另一个地址，为了搞懂这个流程首先要明确这个和银行账户的区别，那这里这个地址的概念和银行里的账户的概念其实本质上是不一样的。银行里的账户，资产的变动，会显示`+10,000` `-9,000` 等等，然后个人所拥有的资产就是加加减减得到的。比特币系统中，一个人所拥有的资产就看最新的状态就行了，不用加加减减了，这是得益于比特币所使用的UTXO账户模型， 意思是我转账，要把所有的钱都花掉，这不是意味着我有20个btc，要转1个btc给小明，就得转20个给小明，它是有找零机制的，也就是剩下的19个（暂时先不讨论手续费的问题）会返回到一个新的地址（为了匿名性的考虑，当然也可以返回到原来的地址），但总的来说，一笔交易的输入，他不是说像银行里，我有200，要转150给其他人，然后我的账户减掉150，剩下50，其他人账户上加150，不是这样的，因为没有一个中心机构做这件事，在比特币系统中，是200都得参与交易，**那这笔交易的输出就是`UTXO`**,中文叫未花费过的交易输出，对比银行基于账户模型，一个重过程，一个重结果。这就很直白了，那是谁控制这这些`UTXO`呢，就是掌握其地址相对应的私钥的人，可以花费这笔币。**总的来说，我要转1个btc给A，那么这个输入一定是之前某个交易的输出，或者好几笔输出的组合（总之输入值要大于交易额），而且我拥有这些之前交易输出的地址的所有权。**

**那之前别人转给我的地址，是怎么让我拥有这个地址的所有权的呢？或者我转给其他人，是怎么保证只能这个人能用这笔钱的呢？**
这就涉及到另一个概念了，比特币脚本。其实我感觉比特币系统中做的最多的操作就是证明，证明我拥有转账地址所对应唯一的私钥，证明签名是正确的，(最主要的原因是加密算法都是单向的，所以只能做验证结果是不是一样的，而不是做验证起点是不是一样的操作)我就可以花别人转给我这个地址上的币了。一个比特币交易的数据结构是这样婶儿的

```json
{
  "version": 1,
  "locktime": 0,
  "vin": [
    {
      "txid":"7957a35fe64f80d234d76d83a2a8f1a0d8149a41d81de548f0a65a8a999f6f18",
      "vout": 0,
      "scriptSig": "3045022100884d142d86652a3f47ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb02204b9f039ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e3813[ALL] 0484ecc0d46f1918b30928fa0e4ed99f16a0fb4fde0735e7ade8416ab9fe423cc5412336376789d172787ec3457eee41c04f4938de5cc17b4a10fa336a8d752adf",
      "sequence": 4294967295
    }
 ],
  "vout": [
    {
      "value": 0.01500000,
      "scriptPubKey": "OP_DUP OP_HASH160 ab68025513c3dbd2f7b92a94e0581f5d50f654e7 OP_EQUALVERIFY OP_CHECKSIG"
    },
    {
      "value": 0.08450000,
      "scriptPubKey": "OP_DUP OP_HASH160 7f9b1a7fb68d60c536c2fd8aeaa53a8f3cc025a8 OP_EQUALVERIFY OP_CHECKSIG",
    }
  ]
}

```

一笔交易能够用多少，就是通过输出的`value`值体现的。

**辣个`scriptPubKey`就是比特币的堆栈脚本，上面把输出比作一把锁，那么要用这把锁锁住的币的人要用钥匙，验证的方式就是他要提供签名和公钥，最终要执行的脚本是这样的

![script](http://onexs3cnv.bkt.clouddn.com/1785959-e4060555d14bcd28.png)
图片来自《精通比特币2》

前面部分叫解锁脚本，由要解锁的人提供，后面是锁定脚本，是要引用那笔交易的输出（UTXO），然后依次脚本执行堆栈。

![excute1](http://onexs3cnv.bkt.clouddn.com/Screen%20Shot%202018-03-02%20at%2010.25.21%20AM.png)
![excute2](http://onexs3cnv.bkt.clouddn.com/Screen%20Shot%202018-03-02%20at%2010.25.39%20AM.png)

（上面图解释的很清楚了）

** 在上面说地址是由公钥哈希经过`base58`编码而成的，那么其实这个过程是可逆的，编码不是加密，虽然我们转账是给到地址，但是我们是可以由比特币地址得到公钥哈希，所以锁定脚本里`<PubKHash>`就是这么来的**

那么怎么才算拥有这个地址，就是我有钥匙，有**独一无二**的钥匙，怎么才算是一个独一无二的钥匙，首先地址是怎么来的，

私钥->公钥->地址，这里每一步都是单向的。所以在脚本中`EQUALVERIFY`其实做的就是是否你拥有正确能生成这个地址的公钥，其实这部分是将公钥给隐藏起来了的。`CHECKSIG`做的是验证签名是不是有效的。

---
_展开 -- 椭圆曲线加密_

在比特币系统中，用的非对称加密算法是椭圆曲线加密算法，ECC指的是椭圆曲线密码学，公钥是通过椭圆曲线乘法从私钥计算得到的，而ECDSA是椭圆曲线数字签名，是在这个密码体系下的签名算法，

![ecdsa](http://onexs3cnv.bkt.clouddn.com/8490153-e6cb048ad310aeb5.png)

这里的`dA`就是私钥,公钥则是用来验证私钥的签名的正确性

![verify](http://onexs3cnv.bkt.clouddn.com/8490153-7f2dd00d3eb43ec0.png)

这里的`Qa`就是公钥，具体的可以看《精通比特币2》的第六章

_关闭 -- 椭圆曲线加密_

---

因为私钥，公钥，地址，三者关系是密不可分的，`EQUALVERIFY`的意义其实就是验证我这把钥匙是对着这把锁的，公钥和地址的联系通过验证体现出来的，`CHECKSIG`的意义是这把锁同时还有声控，必须主人同意才能开锁,私钥和公钥的联系通过签名体现出来的，同时也意味着是我同意了这笔交易，出现问题了就是呈堂证物。签名也另一方面杜绝了，万一公钥被伪造风险或者恰好有另一个公钥经过hash160运算后得到相同的公钥哈希（这是存在的，但如果要同时也对应着私钥，那基本上是不可能的），第一步验证成功，但还需要破解私钥，才能验证签名成功，这样就增加了攻击者的难度

> 公钥是由私钥生成的，通过椭圆曲线(ECPoint)生成，一个私钥经过椭圆曲线变换之后会生成一个65个byte的数组，一般我们会看到这样的一个公钥：04a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd5b8dec5235a0fa8722476c7709c02559e3aa73aa03918ba2d492eea75abea235，公钥一般是把byte数组是经过hex(16进制)的处理之后显示出来的，不同于私钥的Base58,公钥是用来解开私钥签名的数据，使用私钥签名交易之后，会把自己的公钥一起发送，私钥签名的数据可以使用公钥解密，发送公钥之后旷工才能验证私钥的签名的正确性(能不能解开)，私钥和公钥是成对出现的，一个私钥签名的数据，只有对应的公钥才能解开，而地址也是从公钥生成的，这样就可以验证花费的交易是不是属于这个地址的。



_关闭 -- 交易解锁脚本_

---

之所以底层叫区块链，链就体现在我要交易，手上就要有东西，东西来源就当作输入吧，把输入看作一个环扣，输入就是要扣在之前交易的输出上，每个人扣属于自己的，不能乱扣。扣这个动作就是解锁脚本的过程，也就是将解锁脚本和锁定脚本连在一起执行验证的过程，在这个过程中，转账者要用私钥进行签名交易，同时也会将自己的公钥一起发送，这样矿工就能验证私钥签名的有效性，同时这个公钥也必须对应着UTXO的地址（公钥哈希）。


